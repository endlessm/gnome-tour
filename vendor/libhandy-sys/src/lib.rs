// This file was generated by gir (https://github.com/gtk-rs/gir @ 60cbef0)
// from gir-files (https://github.com/gtk-rs/gir-files @ 3043b14)
// DO NOT EDIT

#![allow(non_camel_case_types, non_upper_case_globals, non_snake_case)]
#![allow(
    clippy::approx_constant,
    clippy::type_complexity,
    clippy::unreadable_literal
)]

extern crate gdk_pixbuf_sys as gdk_pixbuf;
extern crate gdk_sys as gdk;
extern crate gio_sys as gio;
extern crate glib_sys as glib;
extern crate gobject_sys as gobject;
extern crate gtk_sys as gtk;
extern crate libc;
extern crate pango_sys as pango;

#[allow(unused_imports)]
use libc::{
    c_char, c_double, c_float, c_int, c_long, c_short, c_uchar, c_uint, c_ulong, c_ushort, c_void,
    intptr_t, size_t, ssize_t, time_t, uintptr_t, FILE,
};

#[allow(unused_imports)]
use glib::{gboolean, gconstpointer, gpointer, GType};

// Enums
pub type HdyCenteringPolicy = c_int;
pub const HDY_CENTERING_POLICY_LOOSE: HdyCenteringPolicy = 0;
pub const HDY_CENTERING_POLICY_STRICT: HdyCenteringPolicy = 1;

pub type HdyDeckTransitionType = c_int;
pub const HDY_DECK_TRANSITION_TYPE_OVER: HdyDeckTransitionType = 0;
pub const HDY_DECK_TRANSITION_TYPE_UNDER: HdyDeckTransitionType = 1;
pub const HDY_DECK_TRANSITION_TYPE_SLIDE: HdyDeckTransitionType = 2;

pub type HdyHeaderGroupChildType = c_int;
pub const HDY_HEADER_GROUP_CHILD_TYPE_HEADER_BAR: HdyHeaderGroupChildType = 0;
pub const HDY_HEADER_GROUP_CHILD_TYPE_GTK_HEADER_BAR: HdyHeaderGroupChildType = 1;
pub const HDY_HEADER_GROUP_CHILD_TYPE_HEADER_GROUP: HdyHeaderGroupChildType = 2;

pub type HdyLeafletTransitionType = c_int;
pub const HDY_LEAFLET_TRANSITION_TYPE_OVER: HdyLeafletTransitionType = 0;
pub const HDY_LEAFLET_TRANSITION_TYPE_UNDER: HdyLeafletTransitionType = 1;
pub const HDY_LEAFLET_TRANSITION_TYPE_SLIDE: HdyLeafletTransitionType = 2;

pub type HdyNavigationDirection = c_int;
pub const HDY_NAVIGATION_DIRECTION_BACK: HdyNavigationDirection = 0;
pub const HDY_NAVIGATION_DIRECTION_FORWARD: HdyNavigationDirection = 1;

pub type HdySqueezerTransitionType = c_int;
pub const HDY_SQUEEZER_TRANSITION_TYPE_NONE: HdySqueezerTransitionType = 0;
pub const HDY_SQUEEZER_TRANSITION_TYPE_CROSSFADE: HdySqueezerTransitionType = 1;

pub type HdyViewSwitcherPolicy = c_int;
pub const HDY_VIEW_SWITCHER_POLICY_AUTO: HdyViewSwitcherPolicy = 0;
pub const HDY_VIEW_SWITCHER_POLICY_NARROW: HdyViewSwitcherPolicy = 1;
pub const HDY_VIEW_SWITCHER_POLICY_WIDE: HdyViewSwitcherPolicy = 2;

// Callbacks
pub type HdyAvatarImageLoadFunc =
    Option<unsafe extern "C" fn(c_int, gpointer) -> *mut gdk_pixbuf::GdkPixbuf>;
pub type HdyComboRowGetEnumValueNameFunc =
    Option<unsafe extern "C" fn(*mut HdyEnumValueObject, gpointer) -> *mut c_char>;
pub type HdyComboRowGetNameFunc =
    Option<unsafe extern "C" fn(*mut gobject::GObject, gpointer) -> *mut c_char>;

// Records
#[repr(C)]
#[derive(Copy, Clone)]
pub struct HdyActionRowClass {
    pub parent_class: gtk::GtkListBoxRowClass,
    pub activate: Option<unsafe extern "C" fn(*mut HdyActionRow)>,
    pub padding: [gpointer; 4],
}

impl ::std::fmt::Debug for HdyActionRowClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("HdyActionRowClass @ {:?}", self as *const _))
            .field("parent_class", &self.parent_class)
            .field("activate", &self.activate)
            .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct HdyApplicationWindowClass {
    pub parent_class: gtk::GtkApplicationWindowClass,
    pub padding: [gpointer; 4],
}

impl ::std::fmt::Debug for HdyApplicationWindowClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!(
            "HdyApplicationWindowClass @ {:?}",
            self as *const _
        ))
        .field("parent_class", &self.parent_class)
        .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct HdyAvatarClass {
    pub parent_class: gtk::GtkDrawingAreaClass,
}

impl ::std::fmt::Debug for HdyAvatarClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("HdyAvatarClass @ {:?}", self as *const _))
            .field("parent_class", &self.parent_class)
            .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct HdyCarouselClass {
    pub parent_class: gtk::GtkEventBoxClass,
}

impl ::std::fmt::Debug for HdyCarouselClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("HdyCarouselClass @ {:?}", self as *const _))
            .field("parent_class", &self.parent_class)
            .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct HdyCarouselIndicatorDotsClass {
    pub parent_class: gtk::GtkDrawingAreaClass,
}

impl ::std::fmt::Debug for HdyCarouselIndicatorDotsClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!(
            "HdyCarouselIndicatorDotsClass @ {:?}",
            self as *const _
        ))
        .field("parent_class", &self.parent_class)
        .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct HdyCarouselIndicatorLinesClass {
    pub parent_class: gtk::GtkDrawingAreaClass,
}

impl ::std::fmt::Debug for HdyCarouselIndicatorLinesClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!(
            "HdyCarouselIndicatorLinesClass @ {:?}",
            self as *const _
        ))
        .field("parent_class", &self.parent_class)
        .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct HdyClampClass {
    pub parent_class: gtk::GtkBinClass,
}

impl ::std::fmt::Debug for HdyClampClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("HdyClampClass @ {:?}", self as *const _))
            .field("parent_class", &self.parent_class)
            .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct HdyComboRowClass {
    pub parent_class: HdyActionRowClass,
    pub padding: [gpointer; 4],
}

impl ::std::fmt::Debug for HdyComboRowClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("HdyComboRowClass @ {:?}", self as *const _))
            .field("parent_class", &self.parent_class)
            .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct HdyDeckClass {
    pub parent_class: gtk::GtkContainerClass,
    pub padding: [gpointer; 4],
}

impl ::std::fmt::Debug for HdyDeckClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("HdyDeckClass @ {:?}", self as *const _))
            .field("parent_class", &self.parent_class)
            .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct HdyEnumValueObjectClass {
    pub parent_class: gobject::GObjectClass,
}

impl ::std::fmt::Debug for HdyEnumValueObjectClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("HdyEnumValueObjectClass @ {:?}", self as *const _))
            .field("parent_class", &self.parent_class)
            .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct HdyExpanderRowClass {
    pub parent_class: HdyPreferencesRowClass,
    pub padding: [gpointer; 4],
}

impl ::std::fmt::Debug for HdyExpanderRowClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("HdyExpanderRowClass @ {:?}", self as *const _))
            .field("parent_class", &self.parent_class)
            .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct HdyHeaderBarClass {
    pub parent_class: gtk::GtkContainerClass,
    pub padding: [gpointer; 4],
}

impl ::std::fmt::Debug for HdyHeaderBarClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("HdyHeaderBarClass @ {:?}", self as *const _))
            .field("parent_class", &self.parent_class)
            .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct HdyHeaderGroupChildClass {
    pub parent_class: gobject::GObjectClass,
}

impl ::std::fmt::Debug for HdyHeaderGroupChildClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!(
            "HdyHeaderGroupChildClass @ {:?}",
            self as *const _
        ))
        .field("parent_class", &self.parent_class)
        .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct HdyHeaderGroupClass {
    pub parent_class: gobject::GObjectClass,
}

impl ::std::fmt::Debug for HdyHeaderGroupClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("HdyHeaderGroupClass @ {:?}", self as *const _))
            .field("parent_class", &self.parent_class)
            .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct HdyKeypadClass {
    pub parent_class: gtk::GtkBinClass,
    pub padding: [gpointer; 4],
}

impl ::std::fmt::Debug for HdyKeypadClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("HdyKeypadClass @ {:?}", self as *const _))
            .field("parent_class", &self.parent_class)
            .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct HdyLeafletClass {
    pub parent_class: gtk::GtkContainerClass,
    pub padding: [gpointer; 4],
}

impl ::std::fmt::Debug for HdyLeafletClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("HdyLeafletClass @ {:?}", self as *const _))
            .field("parent_class", &self.parent_class)
            .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct HdyPreferencesGroupClass {
    pub parent_class: gtk::GtkBinClass,
    pub padding: [gpointer; 4],
}

impl ::std::fmt::Debug for HdyPreferencesGroupClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!(
            "HdyPreferencesGroupClass @ {:?}",
            self as *const _
        ))
        .field("parent_class", &self.parent_class)
        .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct HdyPreferencesPageClass {
    pub parent_class: gtk::GtkBinClass,
    pub padding: [gpointer; 4],
}

impl ::std::fmt::Debug for HdyPreferencesPageClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("HdyPreferencesPageClass @ {:?}", self as *const _))
            .field("parent_class", &self.parent_class)
            .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct HdyPreferencesRowClass {
    pub parent_class: gtk::GtkListBoxRowClass,
    pub padding: [gpointer; 4],
}

impl ::std::fmt::Debug for HdyPreferencesRowClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("HdyPreferencesRowClass @ {:?}", self as *const _))
            .field("parent_class", &self.parent_class)
            .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct HdyPreferencesWindowClass {
    pub parent_class: HdyWindowClass,
    pub padding: [gpointer; 4],
}

impl ::std::fmt::Debug for HdyPreferencesWindowClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!(
            "HdyPreferencesWindowClass @ {:?}",
            self as *const _
        ))
        .field("parent_class", &self.parent_class)
        .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct HdySearchBarClass {
    pub parent_class: gtk::GtkBinClass,
    pub padding: [gpointer; 4],
}

impl ::std::fmt::Debug for HdySearchBarClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("HdySearchBarClass @ {:?}", self as *const _))
            .field("parent_class", &self.parent_class)
            .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct HdySqueezerClass {
    pub parent_class: gtk::GtkContainerClass,
}

impl ::std::fmt::Debug for HdySqueezerClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("HdySqueezerClass @ {:?}", self as *const _))
            .field("parent_class", &self.parent_class)
            .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct HdySwipeGroupClass {
    pub parent_class: gobject::GObjectClass,
}

impl ::std::fmt::Debug for HdySwipeGroupClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("HdySwipeGroupClass @ {:?}", self as *const _))
            .field("parent_class", &self.parent_class)
            .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct HdySwipeTrackerClass {
    pub parent_class: gobject::GObjectClass,
}

impl ::std::fmt::Debug for HdySwipeTrackerClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("HdySwipeTrackerClass @ {:?}", self as *const _))
            .field("parent_class", &self.parent_class)
            .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct HdySwipeableInterface {
    pub parent: gobject::GTypeInterface,
    pub switch_child: Option<unsafe extern "C" fn(*mut HdySwipeable, c_uint, i64)>,
    pub get_swipe_tracker: Option<unsafe extern "C" fn(*mut HdySwipeable) -> *mut HdySwipeTracker>,
    pub get_distance: Option<unsafe extern "C" fn(*mut HdySwipeable) -> c_double>,
    pub get_snap_points:
        Option<unsafe extern "C" fn(*mut HdySwipeable, *mut c_int) -> *mut c_double>,
    pub get_progress: Option<unsafe extern "C" fn(*mut HdySwipeable) -> c_double>,
    pub get_cancel_progress: Option<unsafe extern "C" fn(*mut HdySwipeable) -> c_double>,
    pub get_swipe_area: Option<
        unsafe extern "C" fn(
            *mut HdySwipeable,
            HdyNavigationDirection,
            gboolean,
            *mut gdk::GdkRectangle,
        ),
    >,
    pub padding: [gpointer; 4],
}

impl ::std::fmt::Debug for HdySwipeableInterface {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("HdySwipeableInterface @ {:?}", self as *const _))
            .field("parent", &self.parent)
            .field("switch_child", &self.switch_child)
            .field("get_swipe_tracker", &self.get_swipe_tracker)
            .field("get_distance", &self.get_distance)
            .field("get_snap_points", &self.get_snap_points)
            .field("get_progress", &self.get_progress)
            .field("get_cancel_progress", &self.get_cancel_progress)
            .field("get_swipe_area", &self.get_swipe_area)
            .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct HdyTitleBarClass {
    pub parent_class: gtk::GtkBinClass,
}

impl ::std::fmt::Debug for HdyTitleBarClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("HdyTitleBarClass @ {:?}", self as *const _))
            .field("parent_class", &self.parent_class)
            .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct HdyValueObjectClass {
    pub parent_class: gobject::GObjectClass,
}

impl ::std::fmt::Debug for HdyValueObjectClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("HdyValueObjectClass @ {:?}", self as *const _))
            .field("parent_class", &self.parent_class)
            .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct HdyViewSwitcherBarClass {
    pub parent_class: gtk::GtkBinClass,
}

impl ::std::fmt::Debug for HdyViewSwitcherBarClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("HdyViewSwitcherBarClass @ {:?}", self as *const _))
            .field("parent_class", &self.parent_class)
            .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct HdyViewSwitcherClass {
    pub parent_class: gtk::GtkBinClass,
}

impl ::std::fmt::Debug for HdyViewSwitcherClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("HdyViewSwitcherClass @ {:?}", self as *const _))
            .field("parent_class", &self.parent_class)
            .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct HdyViewSwitcherTitleClass {
    pub parent_class: gtk::GtkBinClass,
}

impl ::std::fmt::Debug for HdyViewSwitcherTitleClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!(
            "HdyViewSwitcherTitleClass @ {:?}",
            self as *const _
        ))
        .field("parent_class", &self.parent_class)
        .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct HdyWindowClass {
    pub parent_class: gtk::GtkWindowClass,
    pub padding: [gpointer; 4],
}

impl ::std::fmt::Debug for HdyWindowClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("HdyWindowClass @ {:?}", self as *const _))
            .field("parent_class", &self.parent_class)
            .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct HdyWindowHandleClass {
    pub parent_class: gtk::GtkEventBoxClass,
}

impl ::std::fmt::Debug for HdyWindowHandleClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("HdyWindowHandleClass @ {:?}", self as *const _))
            .field("parent_class", &self.parent_class)
            .finish()
    }
}

// Classes
#[repr(C)]
#[derive(Copy, Clone)]
pub struct HdyActionRow {
    pub parent_instance: HdyPreferencesRow,
}

impl ::std::fmt::Debug for HdyActionRow {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("HdyActionRow @ {:?}", self as *const _))
            .field("parent_instance", &self.parent_instance)
            .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct HdyApplicationWindow {
    pub parent_instance: gtk::GtkApplicationWindow,
}

impl ::std::fmt::Debug for HdyApplicationWindow {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("HdyApplicationWindow @ {:?}", self as *const _))
            .field("parent_instance", &self.parent_instance)
            .finish()
    }
}

#[repr(C)]
pub struct HdyAvatar(c_void);

impl ::std::fmt::Debug for HdyAvatar {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("HdyAvatar @ {:?}", self as *const _))
            .finish()
    }
}

#[repr(C)]
pub struct HdyCarousel(c_void);

impl ::std::fmt::Debug for HdyCarousel {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("HdyCarousel @ {:?}", self as *const _))
            .finish()
    }
}

#[repr(C)]
pub struct HdyCarouselIndicatorDots(c_void);

impl ::std::fmt::Debug for HdyCarouselIndicatorDots {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!(
            "HdyCarouselIndicatorDots @ {:?}",
            self as *const _
        ))
        .finish()
    }
}

#[repr(C)]
pub struct HdyCarouselIndicatorLines(c_void);

impl ::std::fmt::Debug for HdyCarouselIndicatorLines {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!(
            "HdyCarouselIndicatorLines @ {:?}",
            self as *const _
        ))
        .finish()
    }
}

#[repr(C)]
pub struct HdyClamp(c_void);

impl ::std::fmt::Debug for HdyClamp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("HdyClamp @ {:?}", self as *const _))
            .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct HdyComboRow {
    pub parent_instance: HdyActionRow,
}

impl ::std::fmt::Debug for HdyComboRow {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("HdyComboRow @ {:?}", self as *const _))
            .field("parent_instance", &self.parent_instance)
            .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct HdyDeck {
    pub parent_instance: gtk::GtkContainer,
}

impl ::std::fmt::Debug for HdyDeck {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("HdyDeck @ {:?}", self as *const _))
            .field("parent_instance", &self.parent_instance)
            .finish()
    }
}

#[repr(C)]
pub struct HdyEnumValueObject(c_void);

impl ::std::fmt::Debug for HdyEnumValueObject {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("HdyEnumValueObject @ {:?}", self as *const _))
            .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct HdyExpanderRow {
    pub parent_instance: HdyPreferencesRow,
}

impl ::std::fmt::Debug for HdyExpanderRow {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("HdyExpanderRow @ {:?}", self as *const _))
            .field("parent_instance", &self.parent_instance)
            .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct HdyHeaderBar {
    pub parent_instance: gtk::GtkContainer,
}

impl ::std::fmt::Debug for HdyHeaderBar {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("HdyHeaderBar @ {:?}", self as *const _))
            .field("parent_instance", &self.parent_instance)
            .finish()
    }
}

#[repr(C)]
pub struct HdyHeaderGroup(c_void);

impl ::std::fmt::Debug for HdyHeaderGroup {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("HdyHeaderGroup @ {:?}", self as *const _))
            .finish()
    }
}

#[repr(C)]
pub struct HdyHeaderGroupChild(c_void);

impl ::std::fmt::Debug for HdyHeaderGroupChild {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("HdyHeaderGroupChild @ {:?}", self as *const _))
            .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct HdyKeypad {
    pub parent_instance: gtk::GtkBin,
}

impl ::std::fmt::Debug for HdyKeypad {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("HdyKeypad @ {:?}", self as *const _))
            .field("parent_instance", &self.parent_instance)
            .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct HdyLeaflet {
    pub parent_instance: gtk::GtkContainer,
}

impl ::std::fmt::Debug for HdyLeaflet {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("HdyLeaflet @ {:?}", self as *const _))
            .field("parent_instance", &self.parent_instance)
            .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct HdyPreferencesGroup {
    pub parent_instance: gtk::GtkBin,
}

impl ::std::fmt::Debug for HdyPreferencesGroup {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("HdyPreferencesGroup @ {:?}", self as *const _))
            .field("parent_instance", &self.parent_instance)
            .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct HdyPreferencesPage {
    pub parent_instance: gtk::GtkBin,
}

impl ::std::fmt::Debug for HdyPreferencesPage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("HdyPreferencesPage @ {:?}", self as *const _))
            .field("parent_instance", &self.parent_instance)
            .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct HdyPreferencesRow {
    pub parent_instance: gtk::GtkListBoxRow,
}

impl ::std::fmt::Debug for HdyPreferencesRow {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("HdyPreferencesRow @ {:?}", self as *const _))
            .field("parent_instance", &self.parent_instance)
            .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct HdyPreferencesWindow {
    pub parent_instance: HdyWindow,
}

impl ::std::fmt::Debug for HdyPreferencesWindow {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("HdyPreferencesWindow @ {:?}", self as *const _))
            .field("parent_instance", &self.parent_instance)
            .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct HdySearchBar {
    pub parent_instance: gtk::GtkBin,
}

impl ::std::fmt::Debug for HdySearchBar {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("HdySearchBar @ {:?}", self as *const _))
            .field("parent_instance", &self.parent_instance)
            .finish()
    }
}

#[repr(C)]
pub struct HdySqueezer(c_void);

impl ::std::fmt::Debug for HdySqueezer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("HdySqueezer @ {:?}", self as *const _))
            .finish()
    }
}

#[repr(C)]
pub struct HdySwipeGroup(c_void);

impl ::std::fmt::Debug for HdySwipeGroup {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("HdySwipeGroup @ {:?}", self as *const _))
            .finish()
    }
}

#[repr(C)]
pub struct HdySwipeTracker(c_void);

impl ::std::fmt::Debug for HdySwipeTracker {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("HdySwipeTracker @ {:?}", self as *const _))
            .finish()
    }
}

#[repr(C)]
pub struct HdyTitleBar(c_void);

impl ::std::fmt::Debug for HdyTitleBar {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("HdyTitleBar @ {:?}", self as *const _))
            .finish()
    }
}

#[repr(C)]
pub struct HdyValueObject(c_void);

impl ::std::fmt::Debug for HdyValueObject {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("HdyValueObject @ {:?}", self as *const _))
            .finish()
    }
}

#[repr(C)]
pub struct HdyViewSwitcher(c_void);

impl ::std::fmt::Debug for HdyViewSwitcher {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("HdyViewSwitcher @ {:?}", self as *const _))
            .finish()
    }
}

#[repr(C)]
pub struct HdyViewSwitcherBar(c_void);

impl ::std::fmt::Debug for HdyViewSwitcherBar {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("HdyViewSwitcherBar @ {:?}", self as *const _))
            .finish()
    }
}

#[repr(C)]
pub struct HdyViewSwitcherTitle(c_void);

impl ::std::fmt::Debug for HdyViewSwitcherTitle {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("HdyViewSwitcherTitle @ {:?}", self as *const _))
            .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct HdyWindow {
    pub parent_instance: gtk::GtkWindow,
}

impl ::std::fmt::Debug for HdyWindow {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("HdyWindow @ {:?}", self as *const _))
            .field("parent_instance", &self.parent_instance)
            .finish()
    }
}

#[repr(C)]
pub struct HdyWindowHandle(c_void);

impl ::std::fmt::Debug for HdyWindowHandle {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("HdyWindowHandle @ {:?}", self as *const _))
            .finish()
    }
}

// Interfaces
#[repr(C)]
pub struct HdySwipeable(c_void);

impl ::std::fmt::Debug for HdySwipeable {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "HdySwipeable @ {:?}", self as *const _)
    }
}

extern "C" {

    //=========================================================================
    // HdyCenteringPolicy
    //=========================================================================
    pub fn hdy_centering_policy_get_type() -> GType;

    //=========================================================================
    // HdyDeckTransitionType
    //=========================================================================
    pub fn hdy_deck_transition_type_get_type() -> GType;

    //=========================================================================
    // HdyHeaderGroupChildType
    //=========================================================================
    pub fn hdy_header_group_child_type_get_type() -> GType;

    //=========================================================================
    // HdyLeafletTransitionType
    //=========================================================================
    pub fn hdy_leaflet_transition_type_get_type() -> GType;

    //=========================================================================
    // HdyNavigationDirection
    //=========================================================================
    pub fn hdy_navigation_direction_get_type() -> GType;

    //=========================================================================
    // HdySqueezerTransitionType
    //=========================================================================
    pub fn hdy_squeezer_transition_type_get_type() -> GType;

    //=========================================================================
    // HdyViewSwitcherPolicy
    //=========================================================================
    pub fn hdy_view_switcher_policy_get_type() -> GType;

    //=========================================================================
    // HdyActionRow
    //=========================================================================
    pub fn hdy_action_row_get_type() -> GType;
    pub fn hdy_action_row_new() -> *mut gtk::GtkWidget;
    pub fn hdy_action_row_activate(self_: *mut HdyActionRow);
    pub fn hdy_action_row_add_prefix(self_: *mut HdyActionRow, widget: *mut gtk::GtkWidget);
    pub fn hdy_action_row_get_activatable_widget(self_: *mut HdyActionRow) -> *mut gtk::GtkWidget;
    pub fn hdy_action_row_get_icon_name(self_: *mut HdyActionRow) -> *const c_char;
    pub fn hdy_action_row_get_subtitle(self_: *mut HdyActionRow) -> *const c_char;
    pub fn hdy_action_row_get_use_underline(self_: *mut HdyActionRow) -> gboolean;
    pub fn hdy_action_row_set_activatable_widget(
        self_: *mut HdyActionRow,
        widget: *mut gtk::GtkWidget,
    );
    pub fn hdy_action_row_set_icon_name(self_: *mut HdyActionRow, icon_name: *const c_char);
    pub fn hdy_action_row_set_subtitle(self_: *mut HdyActionRow, subtitle: *const c_char);
    pub fn hdy_action_row_set_use_underline(self_: *mut HdyActionRow, use_underline: gboolean);

    //=========================================================================
    // HdyApplicationWindow
    //=========================================================================
    pub fn hdy_application_window_get_type() -> GType;
    pub fn hdy_application_window_new() -> *mut gtk::GtkWidget;

    //=========================================================================
    // HdyAvatar
    //=========================================================================
    pub fn hdy_avatar_get_type() -> GType;
    pub fn hdy_avatar_new(
        size: c_int,
        text: *const c_char,
        show_initials: gboolean,
    ) -> *mut gtk::GtkWidget;
    pub fn hdy_avatar_get_icon_name(self_: *mut HdyAvatar) -> *const c_char;
    pub fn hdy_avatar_get_show_initials(self_: *mut HdyAvatar) -> gboolean;
    pub fn hdy_avatar_get_size(self_: *mut HdyAvatar) -> c_int;
    pub fn hdy_avatar_get_text(self_: *mut HdyAvatar) -> *const c_char;
    pub fn hdy_avatar_set_icon_name(self_: *mut HdyAvatar, icon_name: *const c_char);
    pub fn hdy_avatar_set_image_load_func(
        self_: *mut HdyAvatar,
        load_image: HdyAvatarImageLoadFunc,
        user_data: gpointer,
        destroy: glib::GDestroyNotify,
    );
    pub fn hdy_avatar_set_show_initials(self_: *mut HdyAvatar, show_initials: gboolean);
    pub fn hdy_avatar_set_size(self_: *mut HdyAvatar, size: c_int);
    pub fn hdy_avatar_set_text(self_: *mut HdyAvatar, text: *const c_char);

    //=========================================================================
    // HdyCarousel
    //=========================================================================
    pub fn hdy_carousel_get_type() -> GType;
    pub fn hdy_carousel_new() -> *mut gtk::GtkWidget;
    pub fn hdy_carousel_get_allow_mouse_drag(self_: *mut HdyCarousel) -> gboolean;
    pub fn hdy_carousel_get_animation_duration(self_: *mut HdyCarousel) -> c_uint;
    pub fn hdy_carousel_get_interactive(self_: *mut HdyCarousel) -> gboolean;
    pub fn hdy_carousel_get_n_pages(self_: *mut HdyCarousel) -> c_uint;
    pub fn hdy_carousel_get_position(self_: *mut HdyCarousel) -> c_double;
    pub fn hdy_carousel_get_reveal_duration(self_: *mut HdyCarousel) -> c_uint;
    pub fn hdy_carousel_get_spacing(self_: *mut HdyCarousel) -> c_uint;
    pub fn hdy_carousel_insert(
        self_: *mut HdyCarousel,
        child: *mut gtk::GtkWidget,
        position: c_int,
    );
    pub fn hdy_carousel_prepend(self_: *mut HdyCarousel, child: *mut gtk::GtkWidget);
    pub fn hdy_carousel_reorder(
        self_: *mut HdyCarousel,
        child: *mut gtk::GtkWidget,
        position: c_int,
    );
    pub fn hdy_carousel_scroll_to(self_: *mut HdyCarousel, widget: *mut gtk::GtkWidget);
    pub fn hdy_carousel_scroll_to_full(
        self_: *mut HdyCarousel,
        widget: *mut gtk::GtkWidget,
        duration: i64,
    );
    pub fn hdy_carousel_set_allow_mouse_drag(self_: *mut HdyCarousel, allow_mouse_drag: gboolean);
    pub fn hdy_carousel_set_animation_duration(self_: *mut HdyCarousel, duration: c_uint);
    pub fn hdy_carousel_set_interactive(self_: *mut HdyCarousel, interactive: gboolean);
    pub fn hdy_carousel_set_reveal_duration(self_: *mut HdyCarousel, reveal_duration: c_uint);
    pub fn hdy_carousel_set_spacing(self_: *mut HdyCarousel, spacing: c_uint);

    //=========================================================================
    // HdyCarouselIndicatorDots
    //=========================================================================
    pub fn hdy_carousel_indicator_dots_get_type() -> GType;
    pub fn hdy_carousel_indicator_dots_new() -> *mut gtk::GtkWidget;
    pub fn hdy_carousel_indicator_dots_get_carousel(
        self_: *mut HdyCarouselIndicatorDots,
    ) -> *mut HdyCarousel;
    pub fn hdy_carousel_indicator_dots_set_carousel(
        self_: *mut HdyCarouselIndicatorDots,
        carousel: *mut HdyCarousel,
    );

    //=========================================================================
    // HdyCarouselIndicatorLines
    //=========================================================================
    pub fn hdy_carousel_indicator_lines_get_type() -> GType;
    pub fn hdy_carousel_indicator_lines_new() -> *mut gtk::GtkWidget;
    pub fn hdy_carousel_indicator_lines_get_carousel(
        self_: *mut HdyCarouselIndicatorLines,
    ) -> *mut HdyCarousel;
    pub fn hdy_carousel_indicator_lines_set_carousel(
        self_: *mut HdyCarouselIndicatorLines,
        carousel: *mut HdyCarousel,
    );

    //=========================================================================
    // HdyClamp
    //=========================================================================
    pub fn hdy_clamp_get_type() -> GType;
    pub fn hdy_clamp_new() -> *mut gtk::GtkWidget;
    pub fn hdy_clamp_get_maximum_size(self_: *mut HdyClamp) -> c_int;
    pub fn hdy_clamp_get_tightening_threshold(self_: *mut HdyClamp) -> c_int;
    pub fn hdy_clamp_set_maximum_size(self_: *mut HdyClamp, maximum_size: c_int);
    pub fn hdy_clamp_set_tightening_threshold(self_: *mut HdyClamp, tightening_threshold: c_int);

    //=========================================================================
    // HdyComboRow
    //=========================================================================
    pub fn hdy_combo_row_get_type() -> GType;
    pub fn hdy_combo_row_new() -> *mut gtk::GtkWidget;
    pub fn hdy_combo_row_bind_model(
        self_: *mut HdyComboRow,
        model: *mut gio::GListModel,
        create_list_widget_func: gtk::GtkListBoxCreateWidgetFunc,
        create_current_widget_func: gtk::GtkListBoxCreateWidgetFunc,
        user_data: gpointer,
        user_data_free_func: glib::GDestroyNotify,
    );
    pub fn hdy_combo_row_bind_name_model(
        self_: *mut HdyComboRow,
        model: *mut gio::GListModel,
        get_name_func: HdyComboRowGetNameFunc,
        user_data: gpointer,
        user_data_free_func: glib::GDestroyNotify,
    );
    pub fn hdy_combo_row_get_model(self_: *mut HdyComboRow) -> *mut gio::GListModel;
    pub fn hdy_combo_row_get_selected_index(self_: *mut HdyComboRow) -> c_int;
    pub fn hdy_combo_row_get_use_subtitle(self_: *mut HdyComboRow) -> gboolean;
    pub fn hdy_combo_row_set_for_enum(
        self_: *mut HdyComboRow,
        enum_type: GType,
        get_name_func: HdyComboRowGetEnumValueNameFunc,
        user_data: gpointer,
        user_data_free_func: glib::GDestroyNotify,
    );
    pub fn hdy_combo_row_set_get_name_func(
        self_: *mut HdyComboRow,
        get_name_func: HdyComboRowGetNameFunc,
        user_data: gpointer,
        user_data_free_func: glib::GDestroyNotify,
    );
    pub fn hdy_combo_row_set_selected_index(self_: *mut HdyComboRow, selected_index: c_int);
    pub fn hdy_combo_row_set_use_subtitle(self_: *mut HdyComboRow, use_subtitle: gboolean);

    //=========================================================================
    // HdyDeck
    //=========================================================================
    pub fn hdy_deck_get_type() -> GType;
    pub fn hdy_deck_new() -> *mut gtk::GtkWidget;
    pub fn hdy_deck_get_adjacent_child(
        self_: *mut HdyDeck,
        direction: HdyNavigationDirection,
    ) -> *mut gtk::GtkWidget;
    pub fn hdy_deck_get_can_swipe_back(self_: *mut HdyDeck) -> gboolean;
    pub fn hdy_deck_get_can_swipe_forward(self_: *mut HdyDeck) -> gboolean;
    pub fn hdy_deck_get_child_by_name(
        self_: *mut HdyDeck,
        name: *const c_char,
    ) -> *mut gtk::GtkWidget;
    pub fn hdy_deck_get_homogeneous(
        self_: *mut HdyDeck,
        orientation: gtk::GtkOrientation,
    ) -> gboolean;
    pub fn hdy_deck_get_interpolate_size(self_: *mut HdyDeck) -> gboolean;
    pub fn hdy_deck_get_transition_duration(self_: *mut HdyDeck) -> c_uint;
    pub fn hdy_deck_get_transition_running(self_: *mut HdyDeck) -> gboolean;
    pub fn hdy_deck_get_transition_type(self_: *mut HdyDeck) -> HdyDeckTransitionType;
    pub fn hdy_deck_get_visible_child(self_: *mut HdyDeck) -> *mut gtk::GtkWidget;
    pub fn hdy_deck_get_visible_child_name(self_: *mut HdyDeck) -> *const c_char;
    pub fn hdy_deck_navigate(self_: *mut HdyDeck, direction: HdyNavigationDirection) -> gboolean;
    pub fn hdy_deck_set_can_swipe_back(self_: *mut HdyDeck, can_swipe_back: gboolean);
    pub fn hdy_deck_set_can_swipe_forward(self_: *mut HdyDeck, can_swipe_forward: gboolean);
    pub fn hdy_deck_set_homogeneous(
        self_: *mut HdyDeck,
        orientation: gtk::GtkOrientation,
        homogeneous: gboolean,
    );
    pub fn hdy_deck_set_interpolate_size(self_: *mut HdyDeck, interpolate_size: gboolean);
    pub fn hdy_deck_set_transition_duration(self_: *mut HdyDeck, duration: c_uint);
    pub fn hdy_deck_set_transition_type(self_: *mut HdyDeck, transition: HdyDeckTransitionType);
    pub fn hdy_deck_set_visible_child(self_: *mut HdyDeck, visible_child: *mut gtk::GtkWidget);
    pub fn hdy_deck_set_visible_child_name(self_: *mut HdyDeck, name: *const c_char);

    //=========================================================================
    // HdyEnumValueObject
    //=========================================================================
    pub fn hdy_enum_value_object_get_type() -> GType;
    pub fn hdy_enum_value_object_new(
        enum_value: *mut gobject::GEnumValue,
    ) -> *mut HdyEnumValueObject;
    pub fn hdy_enum_value_object_get_name(self_: *mut HdyEnumValueObject) -> *const c_char;
    pub fn hdy_enum_value_object_get_nick(self_: *mut HdyEnumValueObject) -> *const c_char;
    pub fn hdy_enum_value_object_get_value(self_: *mut HdyEnumValueObject) -> c_int;

    //=========================================================================
    // HdyExpanderRow
    //=========================================================================
    pub fn hdy_expander_row_get_type() -> GType;
    pub fn hdy_expander_row_new() -> *mut gtk::GtkWidget;
    pub fn hdy_expander_row_add_action(self_: *mut HdyExpanderRow, widget: *mut gtk::GtkWidget);
    pub fn hdy_expander_row_add_prefix(self_: *mut HdyExpanderRow, widget: *mut gtk::GtkWidget);
    pub fn hdy_expander_row_get_enable_expansion(self_: *mut HdyExpanderRow) -> gboolean;
    pub fn hdy_expander_row_get_expanded(self_: *mut HdyExpanderRow) -> gboolean;
    pub fn hdy_expander_row_get_icon_name(self_: *mut HdyExpanderRow) -> *const c_char;
    pub fn hdy_expander_row_get_show_enable_switch(self_: *mut HdyExpanderRow) -> gboolean;
    pub fn hdy_expander_row_get_subtitle(self_: *mut HdyExpanderRow) -> *const c_char;
    pub fn hdy_expander_row_get_use_underline(self_: *mut HdyExpanderRow) -> gboolean;
    pub fn hdy_expander_row_set_enable_expansion(
        self_: *mut HdyExpanderRow,
        enable_expansion: gboolean,
    );
    pub fn hdy_expander_row_set_expanded(self_: *mut HdyExpanderRow, expanded: gboolean);
    pub fn hdy_expander_row_set_icon_name(self_: *mut HdyExpanderRow, icon_name: *const c_char);
    pub fn hdy_expander_row_set_show_enable_switch(
        self_: *mut HdyExpanderRow,
        show_enable_switch: gboolean,
    );
    pub fn hdy_expander_row_set_subtitle(self_: *mut HdyExpanderRow, subtitle: *const c_char);
    pub fn hdy_expander_row_set_use_underline(self_: *mut HdyExpanderRow, use_underline: gboolean);

    //=========================================================================
    // HdyHeaderBar
    //=========================================================================
    pub fn hdy_header_bar_get_type() -> GType;
    pub fn hdy_header_bar_new() -> *mut gtk::GtkWidget;
    pub fn hdy_header_bar_get_centering_policy(self_: *mut HdyHeaderBar) -> HdyCenteringPolicy;
    pub fn hdy_header_bar_get_custom_title(self_: *mut HdyHeaderBar) -> *mut gtk::GtkWidget;
    pub fn hdy_header_bar_get_decoration_layout(self_: *mut HdyHeaderBar) -> *const c_char;
    pub fn hdy_header_bar_get_has_subtitle(self_: *mut HdyHeaderBar) -> gboolean;
    pub fn hdy_header_bar_get_interpolate_size(self_: *mut HdyHeaderBar) -> gboolean;
    pub fn hdy_header_bar_get_show_close_button(self_: *mut HdyHeaderBar) -> gboolean;
    pub fn hdy_header_bar_get_subtitle(self_: *mut HdyHeaderBar) -> *const c_char;
    pub fn hdy_header_bar_get_title(self_: *mut HdyHeaderBar) -> *const c_char;
    pub fn hdy_header_bar_get_transition_duration(self_: *mut HdyHeaderBar) -> c_uint;
    pub fn hdy_header_bar_get_transition_running(self_: *mut HdyHeaderBar) -> gboolean;
    pub fn hdy_header_bar_pack_end(self_: *mut HdyHeaderBar, child: *mut gtk::GtkWidget);
    pub fn hdy_header_bar_pack_start(self_: *mut HdyHeaderBar, child: *mut gtk::GtkWidget);
    pub fn hdy_header_bar_set_centering_policy(
        self_: *mut HdyHeaderBar,
        centering_policy: HdyCenteringPolicy,
    );
    pub fn hdy_header_bar_set_custom_title(
        self_: *mut HdyHeaderBar,
        title_widget: *mut gtk::GtkWidget,
    );
    pub fn hdy_header_bar_set_decoration_layout(self_: *mut HdyHeaderBar, layout: *const c_char);
    pub fn hdy_header_bar_set_has_subtitle(self_: *mut HdyHeaderBar, setting: gboolean);
    pub fn hdy_header_bar_set_interpolate_size(
        self_: *mut HdyHeaderBar,
        interpolate_size: gboolean,
    );
    pub fn hdy_header_bar_set_show_close_button(self_: *mut HdyHeaderBar, setting: gboolean);
    pub fn hdy_header_bar_set_subtitle(self_: *mut HdyHeaderBar, subtitle: *const c_char);
    pub fn hdy_header_bar_set_title(self_: *mut HdyHeaderBar, title: *const c_char);
    pub fn hdy_header_bar_set_transition_duration(self_: *mut HdyHeaderBar, duration: c_uint);

    //=========================================================================
    // HdyHeaderGroup
    //=========================================================================
    pub fn hdy_header_group_get_type() -> GType;
    pub fn hdy_header_group_new() -> *mut HdyHeaderGroup;
    pub fn hdy_header_group_add_gtk_header_bar(
        self_: *mut HdyHeaderGroup,
        header_bar: *mut gtk::GtkHeaderBar,
    );
    pub fn hdy_header_group_add_header_bar(
        self_: *mut HdyHeaderGroup,
        header_bar: *mut HdyHeaderBar,
    );
    pub fn hdy_header_group_add_header_group(
        self_: *mut HdyHeaderGroup,
        header_group: *mut HdyHeaderGroup,
    );
    pub fn hdy_header_group_get_children(self_: *mut HdyHeaderGroup) -> *mut glib::GSList;
    pub fn hdy_header_group_get_decorate_all(self_: *mut HdyHeaderGroup) -> gboolean;
    pub fn hdy_header_group_remove_child(
        self_: *mut HdyHeaderGroup,
        child: *mut HdyHeaderGroupChild,
    );
    pub fn hdy_header_group_remove_gtk_header_bar(
        self_: *mut HdyHeaderGroup,
        header_bar: *mut gtk::GtkHeaderBar,
    );
    pub fn hdy_header_group_remove_header_bar(
        self_: *mut HdyHeaderGroup,
        header_bar: *mut HdyHeaderBar,
    );
    pub fn hdy_header_group_remove_header_group(
        self_: *mut HdyHeaderGroup,
        header_group: *mut HdyHeaderGroup,
    );
    pub fn hdy_header_group_set_decorate_all(self_: *mut HdyHeaderGroup, decorate_all: gboolean);

    //=========================================================================
    // HdyHeaderGroupChild
    //=========================================================================
    pub fn hdy_header_group_child_get_type() -> GType;
    pub fn hdy_header_group_child_get_child_type(
        self_: *mut HdyHeaderGroupChild,
    ) -> HdyHeaderGroupChildType;
    pub fn hdy_header_group_child_get_gtk_header_bar(
        self_: *mut HdyHeaderGroupChild,
    ) -> *mut gtk::GtkHeaderBar;
    pub fn hdy_header_group_child_get_header_bar(
        self_: *mut HdyHeaderGroupChild,
    ) -> *mut HdyHeaderBar;
    pub fn hdy_header_group_child_get_header_group(
        self_: *mut HdyHeaderGroupChild,
    ) -> *mut HdyHeaderGroup;

    //=========================================================================
    // HdyKeypad
    //=========================================================================
    pub fn hdy_keypad_get_type() -> GType;
    pub fn hdy_keypad_new(
        symbols_visible: gboolean,
        letters_visible: gboolean,
    ) -> *mut gtk::GtkWidget;
    pub fn hdy_keypad_get_column_spacing(self_: *mut HdyKeypad) -> c_uint;
    pub fn hdy_keypad_get_end_action(self_: *mut HdyKeypad) -> *mut gtk::GtkWidget;
    pub fn hdy_keypad_get_entry(self_: *mut HdyKeypad) -> *mut gtk::GtkEntry;
    pub fn hdy_keypad_get_letters_visible(self_: *mut HdyKeypad) -> gboolean;
    pub fn hdy_keypad_get_row_spacing(self_: *mut HdyKeypad) -> c_uint;
    pub fn hdy_keypad_get_start_action(self_: *mut HdyKeypad) -> *mut gtk::GtkWidget;
    pub fn hdy_keypad_get_symbols_visible(self_: *mut HdyKeypad) -> gboolean;
    pub fn hdy_keypad_set_column_spacing(self_: *mut HdyKeypad, spacing: c_uint);
    pub fn hdy_keypad_set_end_action(self_: *mut HdyKeypad, end_action: *mut gtk::GtkWidget);
    pub fn hdy_keypad_set_entry(self_: *mut HdyKeypad, entry: *mut gtk::GtkEntry);
    pub fn hdy_keypad_set_letters_visible(self_: *mut HdyKeypad, letters_visible: gboolean);
    pub fn hdy_keypad_set_row_spacing(self_: *mut HdyKeypad, spacing: c_uint);
    pub fn hdy_keypad_set_start_action(self_: *mut HdyKeypad, start_action: *mut gtk::GtkWidget);
    pub fn hdy_keypad_set_symbols_visible(self_: *mut HdyKeypad, symbols_visible: gboolean);

    //=========================================================================
    // HdyLeaflet
    //=========================================================================
    pub fn hdy_leaflet_get_type() -> GType;
    pub fn hdy_leaflet_new() -> *mut gtk::GtkWidget;
    pub fn hdy_leaflet_get_adjacent_child(
        self_: *mut HdyLeaflet,
        direction: HdyNavigationDirection,
    ) -> *mut gtk::GtkWidget;
    pub fn hdy_leaflet_get_can_swipe_back(self_: *mut HdyLeaflet) -> gboolean;
    pub fn hdy_leaflet_get_can_swipe_forward(self_: *mut HdyLeaflet) -> gboolean;
    pub fn hdy_leaflet_get_child_by_name(
        self_: *mut HdyLeaflet,
        name: *const c_char,
    ) -> *mut gtk::GtkWidget;
    pub fn hdy_leaflet_get_child_transition_duration(self_: *mut HdyLeaflet) -> c_uint;
    pub fn hdy_leaflet_get_child_transition_running(self_: *mut HdyLeaflet) -> gboolean;
    pub fn hdy_leaflet_get_folded(self_: *mut HdyLeaflet) -> gboolean;
    pub fn hdy_leaflet_get_homogeneous(
        self_: *mut HdyLeaflet,
        folded: gboolean,
        orientation: gtk::GtkOrientation,
    ) -> gboolean;
    pub fn hdy_leaflet_get_interpolate_size(self_: *mut HdyLeaflet) -> gboolean;
    pub fn hdy_leaflet_get_mode_transition_duration(self_: *mut HdyLeaflet) -> c_uint;
    pub fn hdy_leaflet_get_transition_type(self_: *mut HdyLeaflet) -> HdyLeafletTransitionType;
    pub fn hdy_leaflet_get_visible_child(self_: *mut HdyLeaflet) -> *mut gtk::GtkWidget;
    pub fn hdy_leaflet_get_visible_child_name(self_: *mut HdyLeaflet) -> *const c_char;
    pub fn hdy_leaflet_navigate(
        self_: *mut HdyLeaflet,
        direction: HdyNavigationDirection,
    ) -> gboolean;
    pub fn hdy_leaflet_set_can_swipe_back(self_: *mut HdyLeaflet, can_swipe_back: gboolean);
    pub fn hdy_leaflet_set_can_swipe_forward(self_: *mut HdyLeaflet, can_swipe_forward: gboolean);
    pub fn hdy_leaflet_set_child_transition_duration(self_: *mut HdyLeaflet, duration: c_uint);
    pub fn hdy_leaflet_set_homogeneous(
        self_: *mut HdyLeaflet,
        folded: gboolean,
        orientation: gtk::GtkOrientation,
        homogeneous: gboolean,
    );
    pub fn hdy_leaflet_set_interpolate_size(self_: *mut HdyLeaflet, interpolate_size: gboolean);
    pub fn hdy_leaflet_set_mode_transition_duration(self_: *mut HdyLeaflet, duration: c_uint);
    pub fn hdy_leaflet_set_transition_type(
        self_: *mut HdyLeaflet,
        transition: HdyLeafletTransitionType,
    );
    pub fn hdy_leaflet_set_visible_child(
        self_: *mut HdyLeaflet,
        visible_child: *mut gtk::GtkWidget,
    );
    pub fn hdy_leaflet_set_visible_child_name(self_: *mut HdyLeaflet, name: *const c_char);

    //=========================================================================
    // HdyPreferencesGroup
    //=========================================================================
    pub fn hdy_preferences_group_get_type() -> GType;
    pub fn hdy_preferences_group_new() -> *mut gtk::GtkWidget;
    pub fn hdy_preferences_group_get_description(self_: *mut HdyPreferencesGroup) -> *const c_char;
    pub fn hdy_preferences_group_get_title(self_: *mut HdyPreferencesGroup) -> *const c_char;
    pub fn hdy_preferences_group_set_description(
        self_: *mut HdyPreferencesGroup,
        description: *const c_char,
    );
    pub fn hdy_preferences_group_set_title(self_: *mut HdyPreferencesGroup, title: *const c_char);

    //=========================================================================
    // HdyPreferencesPage
    //=========================================================================
    pub fn hdy_preferences_page_get_type() -> GType;
    pub fn hdy_preferences_page_new() -> *mut gtk::GtkWidget;
    pub fn hdy_preferences_page_get_icon_name(self_: *mut HdyPreferencesPage) -> *const c_char;
    pub fn hdy_preferences_page_get_title(self_: *mut HdyPreferencesPage) -> *const c_char;
    pub fn hdy_preferences_page_set_icon_name(
        self_: *mut HdyPreferencesPage,
        icon_name: *const c_char,
    );
    pub fn hdy_preferences_page_set_title(self_: *mut HdyPreferencesPage, title: *const c_char);

    //=========================================================================
    // HdyPreferencesRow
    //=========================================================================
    pub fn hdy_preferences_row_get_type() -> GType;
    pub fn hdy_preferences_row_new() -> *mut gtk::GtkWidget;
    pub fn hdy_preferences_row_get_title(self_: *mut HdyPreferencesRow) -> *const c_char;
    pub fn hdy_preferences_row_get_use_underline(self_: *mut HdyPreferencesRow) -> gboolean;
    pub fn hdy_preferences_row_set_title(self_: *mut HdyPreferencesRow, title: *const c_char);
    pub fn hdy_preferences_row_set_use_underline(
        self_: *mut HdyPreferencesRow,
        use_underline: gboolean,
    );

    //=========================================================================
    // HdyPreferencesWindow
    //=========================================================================
    pub fn hdy_preferences_window_get_type() -> GType;
    pub fn hdy_preferences_window_new() -> *mut gtk::GtkWidget;
    pub fn hdy_preferences_window_close_subpage(self_: *mut HdyPreferencesWindow);
    pub fn hdy_preferences_window_get_can_swipe_back(self_: *mut HdyPreferencesWindow) -> gboolean;
    pub fn hdy_preferences_window_get_search_enabled(self_: *mut HdyPreferencesWindow) -> gboolean;
    pub fn hdy_preferences_window_present_subpage(
        self_: *mut HdyPreferencesWindow,
        subpage: *mut gtk::GtkWidget,
    );
    pub fn hdy_preferences_window_set_can_swipe_back(
        self_: *mut HdyPreferencesWindow,
        can_swipe_back: gboolean,
    );
    pub fn hdy_preferences_window_set_search_enabled(
        self_: *mut HdyPreferencesWindow,
        search_enabled: gboolean,
    );

    //=========================================================================
    // HdySearchBar
    //=========================================================================
    pub fn hdy_search_bar_get_type() -> GType;
    pub fn hdy_search_bar_new() -> *mut gtk::GtkWidget;
    pub fn hdy_search_bar_connect_entry(self_: *mut HdySearchBar, entry: *mut gtk::GtkEntry);
    pub fn hdy_search_bar_get_search_mode(self_: *mut HdySearchBar) -> gboolean;
    pub fn hdy_search_bar_get_show_close_button(self_: *mut HdySearchBar) -> gboolean;
    pub fn hdy_search_bar_handle_event(
        self_: *mut HdySearchBar,
        event: *mut gdk::GdkEvent,
    ) -> gboolean;
    pub fn hdy_search_bar_set_search_mode(self_: *mut HdySearchBar, search_mode: gboolean);
    pub fn hdy_search_bar_set_show_close_button(self_: *mut HdySearchBar, visible: gboolean);

    //=========================================================================
    // HdySqueezer
    //=========================================================================
    pub fn hdy_squeezer_get_type() -> GType;
    pub fn hdy_squeezer_new() -> *mut gtk::GtkWidget;
    pub fn hdy_squeezer_get_child_enabled(
        self_: *mut HdySqueezer,
        child: *mut gtk::GtkWidget,
    ) -> gboolean;
    pub fn hdy_squeezer_get_homogeneous(self_: *mut HdySqueezer) -> gboolean;
    pub fn hdy_squeezer_get_interpolate_size(self_: *mut HdySqueezer) -> gboolean;
    pub fn hdy_squeezer_get_transition_duration(self_: *mut HdySqueezer) -> c_uint;
    pub fn hdy_squeezer_get_transition_running(self_: *mut HdySqueezer) -> gboolean;
    pub fn hdy_squeezer_get_transition_type(self_: *mut HdySqueezer) -> HdySqueezerTransitionType;
    pub fn hdy_squeezer_get_visible_child(self_: *mut HdySqueezer) -> *mut gtk::GtkWidget;
    pub fn hdy_squeezer_get_xalign(self_: *mut HdySqueezer) -> c_float;
    pub fn hdy_squeezer_get_yalign(self_: *mut HdySqueezer) -> c_float;
    pub fn hdy_squeezer_set_child_enabled(
        self_: *mut HdySqueezer,
        child: *mut gtk::GtkWidget,
        enabled: gboolean,
    );
    pub fn hdy_squeezer_set_homogeneous(self_: *mut HdySqueezer, homogeneous: gboolean);
    pub fn hdy_squeezer_set_interpolate_size(self_: *mut HdySqueezer, interpolate_size: gboolean);
    pub fn hdy_squeezer_set_transition_duration(self_: *mut HdySqueezer, duration: c_uint);
    pub fn hdy_squeezer_set_transition_type(
        self_: *mut HdySqueezer,
        transition: HdySqueezerTransitionType,
    );
    pub fn hdy_squeezer_set_xalign(self_: *mut HdySqueezer, xalign: c_float);
    pub fn hdy_squeezer_set_yalign(self_: *mut HdySqueezer, yalign: c_float);

    //=========================================================================
    // HdySwipeGroup
    //=========================================================================
    pub fn hdy_swipe_group_get_type() -> GType;
    pub fn hdy_swipe_group_new() -> *mut HdySwipeGroup;
    pub fn hdy_swipe_group_add_swipeable(self_: *mut HdySwipeGroup, swipeable: *mut HdySwipeable);
    pub fn hdy_swipe_group_get_swipeables(self_: *mut HdySwipeGroup) -> *mut glib::GSList;
    pub fn hdy_swipe_group_remove_swipeable(
        self_: *mut HdySwipeGroup,
        swipeable: *mut HdySwipeable,
    );

    //=========================================================================
    // HdySwipeTracker
    //=========================================================================
    pub fn hdy_swipe_tracker_get_type() -> GType;
    pub fn hdy_swipe_tracker_new(swipeable: *mut HdySwipeable) -> *mut HdySwipeTracker;
    pub fn hdy_swipe_tracker_get_allow_mouse_drag(self_: *mut HdySwipeTracker) -> gboolean;
    pub fn hdy_swipe_tracker_get_enabled(self_: *mut HdySwipeTracker) -> gboolean;
    pub fn hdy_swipe_tracker_get_reversed(self_: *mut HdySwipeTracker) -> gboolean;
    pub fn hdy_swipe_tracker_get_swipeable(self_: *mut HdySwipeTracker) -> *mut HdySwipeable;
    pub fn hdy_swipe_tracker_set_allow_mouse_drag(
        self_: *mut HdySwipeTracker,
        allow_mouse_drag: gboolean,
    );
    pub fn hdy_swipe_tracker_set_enabled(self_: *mut HdySwipeTracker, enabled: gboolean);
    pub fn hdy_swipe_tracker_set_reversed(self_: *mut HdySwipeTracker, reversed: gboolean);
    pub fn hdy_swipe_tracker_shift_position(self_: *mut HdySwipeTracker, delta: c_double);

    //=========================================================================
    // HdyTitleBar
    //=========================================================================
    pub fn hdy_title_bar_get_type() -> GType;
    pub fn hdy_title_bar_new() -> *mut gtk::GtkWidget;
    pub fn hdy_title_bar_get_selection_mode(self_: *mut HdyTitleBar) -> gboolean;
    pub fn hdy_title_bar_set_selection_mode(self_: *mut HdyTitleBar, selection_mode: gboolean);

    //=========================================================================
    // HdyValueObject
    //=========================================================================
    pub fn hdy_value_object_get_type() -> GType;
    pub fn hdy_value_object_new(value: *const gobject::GValue) -> *mut HdyValueObject;
    pub fn hdy_value_object_new_collect(type_: GType, ...) -> *mut HdyValueObject;
    pub fn hdy_value_object_new_string(string: *const c_char) -> *mut HdyValueObject;
    pub fn hdy_value_object_new_take_string(string: *mut c_char) -> *mut HdyValueObject;
    pub fn hdy_value_object_copy_value(value: *mut HdyValueObject, dest: *mut gobject::GValue);
    pub fn hdy_value_object_dup_string(value: *mut HdyValueObject) -> *mut c_char;
    pub fn hdy_value_object_get_string(value: *mut HdyValueObject) -> *const c_char;
    pub fn hdy_value_object_get_value(value: *mut HdyValueObject) -> *const gobject::GValue;

    //=========================================================================
    // HdyViewSwitcher
    //=========================================================================
    pub fn hdy_view_switcher_get_type() -> GType;
    pub fn hdy_view_switcher_new() -> *mut gtk::GtkWidget;
    pub fn hdy_view_switcher_get_narrow_ellipsize(
        self_: *mut HdyViewSwitcher,
    ) -> pango::PangoEllipsizeMode;
    pub fn hdy_view_switcher_get_policy(self_: *mut HdyViewSwitcher) -> HdyViewSwitcherPolicy;
    pub fn hdy_view_switcher_get_stack(self_: *mut HdyViewSwitcher) -> *mut gtk::GtkStack;
    pub fn hdy_view_switcher_set_narrow_ellipsize(
        self_: *mut HdyViewSwitcher,
        mode: pango::PangoEllipsizeMode,
    );
    pub fn hdy_view_switcher_set_policy(self_: *mut HdyViewSwitcher, policy: HdyViewSwitcherPolicy);
    pub fn hdy_view_switcher_set_stack(self_: *mut HdyViewSwitcher, stack: *mut gtk::GtkStack);

    //=========================================================================
    // HdyViewSwitcherBar
    //=========================================================================
    pub fn hdy_view_switcher_bar_get_type() -> GType;
    pub fn hdy_view_switcher_bar_new() -> *mut gtk::GtkWidget;
    pub fn hdy_view_switcher_bar_get_policy(
        self_: *mut HdyViewSwitcherBar,
    ) -> HdyViewSwitcherPolicy;
    pub fn hdy_view_switcher_bar_get_reveal(self_: *mut HdyViewSwitcherBar) -> gboolean;
    pub fn hdy_view_switcher_bar_get_stack(self_: *mut HdyViewSwitcherBar) -> *mut gtk::GtkStack;
    pub fn hdy_view_switcher_bar_set_policy(
        self_: *mut HdyViewSwitcherBar,
        policy: HdyViewSwitcherPolicy,
    );
    pub fn hdy_view_switcher_bar_set_reveal(self_: *mut HdyViewSwitcherBar, reveal: gboolean);
    pub fn hdy_view_switcher_bar_set_stack(
        self_: *mut HdyViewSwitcherBar,
        stack: *mut gtk::GtkStack,
    );

    //=========================================================================
    // HdyViewSwitcherTitle
    //=========================================================================
    pub fn hdy_view_switcher_title_get_type() -> GType;
    pub fn hdy_view_switcher_title_new() -> *mut HdyViewSwitcherTitle;
    pub fn hdy_view_switcher_title_get_policy(
        self_: *mut HdyViewSwitcherTitle,
    ) -> HdyViewSwitcherPolicy;
    pub fn hdy_view_switcher_title_get_stack(
        self_: *mut HdyViewSwitcherTitle,
    ) -> *mut gtk::GtkStack;
    pub fn hdy_view_switcher_title_get_subtitle(self_: *mut HdyViewSwitcherTitle) -> *const c_char;
    pub fn hdy_view_switcher_title_get_title(self_: *mut HdyViewSwitcherTitle) -> *const c_char;
    pub fn hdy_view_switcher_title_get_title_visible(self_: *mut HdyViewSwitcherTitle) -> gboolean;
    pub fn hdy_view_switcher_title_get_view_switcher_enabled(
        self_: *mut HdyViewSwitcherTitle,
    ) -> gboolean;
    pub fn hdy_view_switcher_title_set_policy(
        self_: *mut HdyViewSwitcherTitle,
        policy: HdyViewSwitcherPolicy,
    );
    pub fn hdy_view_switcher_title_set_stack(
        self_: *mut HdyViewSwitcherTitle,
        stack: *mut gtk::GtkStack,
    );
    pub fn hdy_view_switcher_title_set_subtitle(
        self_: *mut HdyViewSwitcherTitle,
        subtitle: *const c_char,
    );
    pub fn hdy_view_switcher_title_set_title(
        self_: *mut HdyViewSwitcherTitle,
        title: *const c_char,
    );
    pub fn hdy_view_switcher_title_set_view_switcher_enabled(
        self_: *mut HdyViewSwitcherTitle,
        enabled: gboolean,
    );

    //=========================================================================
    // HdyWindow
    //=========================================================================
    pub fn hdy_window_get_type() -> GType;
    pub fn hdy_window_new() -> *mut gtk::GtkWidget;

    //=========================================================================
    // HdyWindowHandle
    //=========================================================================
    pub fn hdy_window_handle_get_type() -> GType;
    pub fn hdy_window_handle_new() -> *mut gtk::GtkWidget;

    //=========================================================================
    // HdySwipeable
    //=========================================================================
    pub fn hdy_swipeable_get_type() -> GType;
    pub fn hdy_swipeable_emit_child_switched(
        self_: *mut HdySwipeable,
        index: c_uint,
        duration: i64,
    );
    pub fn hdy_swipeable_get_cancel_progress(self_: *mut HdySwipeable) -> c_double;
    pub fn hdy_swipeable_get_distance(self_: *mut HdySwipeable) -> c_double;
    pub fn hdy_swipeable_get_progress(self_: *mut HdySwipeable) -> c_double;
    pub fn hdy_swipeable_get_snap_points(
        self_: *mut HdySwipeable,
        n_snap_points: *mut c_int,
    ) -> *mut c_double;
    pub fn hdy_swipeable_get_swipe_area(
        self_: *mut HdySwipeable,
        navigation_direction: HdyNavigationDirection,
        is_drag: gboolean,
        rect: *mut gdk::GdkRectangle,
    );
    pub fn hdy_swipeable_get_swipe_tracker(self_: *mut HdySwipeable) -> *mut HdySwipeTracker;
    pub fn hdy_swipeable_switch_child(self_: *mut HdySwipeable, index: c_uint, duration: i64);

    //=========================================================================
    // Other functions
    //=========================================================================
    pub fn hdy_ease_out_cubic(t: c_double) -> c_double;
    pub fn hdy_enum_value_row_name(
        value: *mut HdyEnumValueObject,
        user_data: gpointer,
    ) -> *mut c_char;
    pub fn hdy_get_enable_animations(widget: *mut gtk::GtkWidget) -> gboolean;
    pub fn hdy_init();

}
